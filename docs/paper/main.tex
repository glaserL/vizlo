
\title{Vizlo - A Vizualizer for clingo}

\section{Introduction and Motivation}

Answer Set Programming (ASP) approaches have gained interest in the last years. One big issue that limits the prolification of ASP in the wider community is it's untraditional way of programming an encoding, more specificly it's declarativeness.

Almost all traditional programming tools work iteratively. There are partial areas where a more declarative way of thinking is required, e.g. in HTML/XML data Auszeichnung or in modern UI development (Swift UI). This also holds true for tools in artificial intelligence (AI). % Why?

It would be wurscht to discuss, whether programmers should be able to think more declarative. In order to make ASP more usable and widen it's community, any tool that would help newcomers to make their first real steps in the environment should be welcomed. 

XY already suggested a workflow that helps creating ASP encodings by thinking about the encoding in a step wise way: generating, XY XY % TODO: find that stuff and describe it here shortly.

Vizlo borrows from this idea in a sense that we try to group parts of a logic program that are independent of each other together.\footnote{The theoretical inspiration of this has been given to me by Javier Romero}


\section{State of the art}

\subsection{Tagging}

\subsection{Visualization}


\section{Intuition}

In this section we lay out our terminology and then explain how the solving works. 


\subsection{Declarative solving}

A logic program p consists of a number of independent rules. Each rule has a head and a body. 

Because we will use the dependency graph of a program to sort it in an iterative simulation, we require the concept of dependency.A rule R is dependent of another, if there is %steal from slides

A stable model is a possible model that does not violate any rule in the encoding.


\subsection{Reinterpretation as step-wise application of rules}

Also, a logic program $p$ may be compartamentalized into multiple rulesets $rs$. 
For every head in every rule in $rs$, all other rules that have this head is dependent on must be in the same rule set. Intuitively, all rules that *could* add the atom a to a stable model must be in this rule set. 

We call a partial model a model that (write exact same wording as for stable model above) of a partial program. Any partial program may only contain rules of the full program if all rules that this rule depends on are in the partial program as well. In other words, if a ruleset $rs$ is contained in the partial program, all other $rs$ that depend on that one must be in the partial program as well.

Thus, the additional atoms that will be added by applying rs_j to the partial models generated by rs_i will either contain more, the same amount of atoms or will lead to an unsatisfiable state. 

\section{Implementation}

The following section will explain how vizlo implements the solving intution that were presented in the previous section and how the visualization is created from this. This will be rather superficial, see the appendix for more information.
\subsection{Modules}

vizlo consists of three modules, transformation, solving and visualization.
The transformation module takes care of parsing a program, generating the dependency graph and sorting the rule sets according to the dependency graph.
The solving module generates the partial models based on the generated rule sets and collects them in a solving graph.
The visualization module draws the solving graph. 

\subsubsection{Transformation}
The transformation relies heavily on the transformer architecture that has been presented previously (see xy). During the transformation, we extract different kinds of information: We generate a dependency graph with vertex v for each rule and a rule v, u if any literal in the rule of v depends on any head of the rule u. 
We also create a "real" dependency graph % TODO COPY FROM SLIDES
This is slightly different from what is usually considered a dependency graph in clingo, as we not only need to topologically sort the program by their dependency but also guarantee the aforementioned dependency, that % TODO blabla rule set before i,j
The transformation module also takes care of removing loops from the dependency graph, merging rules into rule sets and producing a topological sorting of the rule sets based on the dependency graph.
\subsubsection{Solving}

The solving module is at the heart of vizlo. Based on the 

\subsubsection{Visualization}

\section{Limitations}

\section{Conclusion}

\section{Appendix}



